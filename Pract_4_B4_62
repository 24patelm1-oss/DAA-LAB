def max_crossing_sum(arr, left, mid, right, constraint):
left_sum = float('-inf')
total = 0
max_left = -1
for i in range(mid, left - 1, -1):
total += arr[i]
if total > left_sum and total <= constraint:
left_sum = total
max_left = i
right_sum = float('-inf')
total = 0
max_right = -1
for i in range(mid + 1, right + 1):
total += arr[i]
if total > right_sum and (left_sum + total) <= constraint:
right_sum = total
max_right = i
if left_sum == float('-inf') and right_sum == float('-inf'):
return float('-inf'), -1, -1
return left_sum + right_sum, max_left, max_right

def max_subarray_sum(arr, left, right, constraint):
if left > right:
return float('-inf'), -1, -1

if left == right:
if arr[left] <= constraint:
return arr[left], left, left
else:
return float('-inf'), -1, -1
mid = (left + right) // 2
left_max, l_start, l_end = max_subarray_sum(arr, left, mid,
constraint)
right_max, r_start, r_end = max_subarray_sum(arr, mid + 1, right,
constraint)
cross_max, c_start, c_end = max_crossing_sum(arr, left, mid, right,
constraint)
if left_max >= right_max and left_max >= cross_max:
return left_max, l_start, l_end
elif right_max >= left_max and right_max >= cross_max:
return right_max, r_start, r_end
else:
return cross_max, c_start, c_end

def find_best_allocation(resources, constraint):
if not resources or constraint <= 0:
return "No feasible subarray"
max_sum, start, end = max_subarray_sum(resources, 0, len(resources) -
1, constraint)
if max_sum == float('-inf'):
return "No feasible subarray"
return max_sum, resources[start:end+1]

tests = [
([2, 1, 3, 4], 5),

([2, 2, 2, 2], 4),
([1, 5, 2, 3], 5),
([6, 7, 8], 5),
([1, 2, 3, 2, 1], 5),
([1, 1, 1, 1, 1], 4),
([4, 2, 3, 1], 5),
([], 10),
([1, 2, 3], 0)
]
for arr, c in tests:
print("resources =", arr, "constraint =", c, "â†’",
find_best_allocation(arr, c))
